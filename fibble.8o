# Ball and region set, moved by moveball.
:alias bx v0
:alias by v1
:alias dx v2
:alias dy v3
:alias top v4
:alias left v5
:alias right v6
:alias bottom v7
:alias balldata v7
    
:const BALLDATA_SIZE 8
:const BALLDATA_END 64
:const SHOULD_FILL_MASK_START 1
:const SHOULD_FILL_MASK_FINISH 2

# Move set
:alias px v0
:alias py v1
:alias start v2
:alias finish v3
:alias direction v4
:alias start-target v5
:alias finish-target v6
:alias mark v7
:alias movedata v7

:alias tmp vd
:alias tmp2 ve
:alias tmp3 vc
:alias tmp4 vb
:alias tmp5 va

# Permanent
:alias sign vf

# Fill data
:alias fillstartx v0
:alias fillendx v1
:alias fillstarty v2
:alias fillendy v3
:alias fillshouldfill v4
:alias filldata v4



# Set for-each-ball-action to a valid call
# And then call this
: for-each-ball
    tmp := 0
    loop
        i := b1
        i += tmp
        load balldata
        if dx != 0 begin
            : for-each-ball-action
            0 0
            i := b1
            i += tmp
            save balldata
            tmp += BALLDATA_SIZE
        else 
            tmp := BALLDATA_END
        end
        while tmp != BALLDATA_END
    again
;

: draw-ball 
    i := dot
    sprite bx by 1
;

:macro init-level {
    i := for-each-ball-action
    :unpack 0x2 draw-ball
    save v1
    for-each-ball
}

:macro move-all {
    v8 := start
    v9 := finish
    va := direction
    if direction == 1 then vb := py
    if direction == 2 then vb := px

    i := for-each-ball-action
    :unpack 0x2 moveball
    save v1
    for-each-ball
}

:macro draw-crosshair {
    i := crosshair
    sprite px py 2
    px -= 1
    py -= 1
    sprite px py 2
    px += 1
    py += 1
}


: check-in-region
    tmp2 := 0
    tmp3 := px
    tmp4 := py
    loop
        i := b1
        i += tmp2
        load balldata

        if dx == 0 then return

        if tmp3 >= right then jump next-check
        if tmp3 <= left then jump next-check
        if tmp4 >= bottom then jump next-check
        if tmp4 <= top then jump next-check

        v0 := tmp5
        if v0 == 1 begin
            v1 := left
            v2 := right
        else
            v1 := top
            v2 := bottom 
        end
        i := movetargets
        save v2
        return

        : next-check
        tmp2 += BALLDATA_SIZE
        while tmp2 != BALLDATA_END
    again
;

# in tmp5 = 1 - horizontal
#           2 - vertical
: maybe-start-line-drawing
    check-in-region
    i := moveset
    load movedata
    if direction == tmp5 begin
        draw-crosshair
        if direction == 1 begin
            start := px
            finish := px
            mark := py
        else
            start := py
            finish := py
            mark := px
        end
        i := dot
        sprite px py 1
    end
;


# Called from split-regions, assumes that the ball data
# set at b1 + tmp5 was previously loaded, and will restore it.
:macro handle-region-split bound coord fillloc mask {
    # Save the provided bound to the provided location.
    # This is going to be one of the fill boundaries.
    v0 := bound
    v0 := v0
    i := fillloc
    save v0
    
    i := filldatashouldfill
    load v0
    v1 := mask
    v0 |= v1
    save v0

    # Restore ball data.
    i := b1
    i += tmp5
    load v1
    bound := coord
}

: split-regions
    tmp2 := px
    tmp3 := py
    tmp4 := direction
    tmp5 := 0
    
    i := moveset
    save movedata

    if direction == 1 begin
        v0 := start-target
        v1 := finish-target
        v2 := tmp3
        v3 := tmp3
        v4 := 0
    else 
        v0 := tmp2
        v1 := tmp2
        v2 := start-target
        v3 := finish-target
        v4 := 0
    end
    i := fillset
    save filldata


    loop
        i := b1
        i += tmp5
        load balldata
        
        if dx == 0 then jump next-regions
        if tmp2 <= left then jump next-regions
        if tmp2 >= right then jump next-regions
        if tmp3 <= top then jump next-regions
        if tmp3 >= bottom then jump next-regions

        # splitting horizontal 
        if tmp4 == 1 begin
            if by <= tmp3  begin
                if tmp3 < bottom begin 
                    handle-region-split bottom tmp3 filldataendy SHOULD_FILL_MASK_FINISH
                end
            end
            if by >= tmp3 begin
                if tmp3 > top begin 
                    handle-region-split top tmp3 filldatastarty SHOULD_FILL_MASK_START
                end
            end
        end

        # splitting vertical
        if tmp4 == 2 begin
            if bx <= tmp2 begin
                if tmp2 < right begin
                    handle-region-split right tmp2 filldataendx SHOULD_FILL_MASK_FINISH
                end
            end
            if bx >= tmp2 begin
                if tmp2 > left begin
                    handle-region-split left tmp2 filldatastartx SHOULD_FILL_MASK_START
                end
            end
        end

        save balldata
        : next-regions
        tmp5 += BALLDATA_SIZE
        while tmp5 != BALLDATA_END
    again

    runfill
    
    i := moveset
    load movedata
;

# Active set: moveset
:macro horizontal-step {
    i := dot
    tmp := 0
    if start != start-target begin start -= 1 sprite start py 1 tmp += 1 end
    if start != start-target begin start -= 1 sprite start py 1 tmp += 1 end
    if finish != finish-target begin finish += 1 sprite finish py 1 tmp += 1 end
    if finish != finish-target begin finish += 1 sprite finish py 1 tmp += 1 end
    if tmp == 0 begin
        draw-crosshair
        split-regions 
        direction := 0
    end
}

# Active set: moveset
:macro vertical-step {
    tmp := 0
    i := dot
    if start != start-target begin start -= 1 sprite px start 1 tmp += 1 end
    if start != start-target begin start -= 1 sprite px start 1 tmp += 1 end
    if finish != finish-target begin finish += 1 sprite px finish 1 tmp += 1 end
    if finish != finish-target begin finish += 1 sprite px finish 1 tmp += 1 end
    if tmp == 0 begin
        draw-crosshair
        split-regions 
        direction := 0

    end
}

:macro move-crosshair coord amt bound boundfix {
    draw-crosshair
    coord += amt
    if coord == bound then coord := boundfix
    draw-crosshair
}

# Go through the balls until one isn't one, turn it on
:macro next-level {
    # Undraw all current balls
    init-level
    
    tmp := 0
    loop
        i := b1
        i += tmp
        load balldata
        if dx == 0 begin
            dx := 1
            dy := 1
            tmp := BALLDATA_END
            save balldata
            init-level
        else
            tmp += BALLDATA_SIZE
        end
        while tmp != BALLDATA_END
    again
    tmp := OCTO_KEY_2 
    i := moveset
    load movedata
    loop
        while tmp key 
    again
}

# Clobbers v0-v5
:macro check-keys {
    i := moveset
    load movedata
    if direction == 0 begin
        tmp := OCTO_KEY_W if tmp key begin move-crosshair py -1 255 0 end
        tmp := OCTO_KEY_S if tmp key begin move-crosshair py 1 32 31 end
        tmp := OCTO_KEY_A if tmp key begin move-crosshair px -1 255 0 end
        tmp := OCTO_KEY_D if tmp key begin move-crosshair px 1 64 63 end
        tmp := OCTO_KEY_Q if tmp key begin tmp5 := 2 maybe-start-line-drawing end
        tmp := OCTO_KEY_E if tmp key begin tmp5 := 1 maybe-start-line-drawing end
        tmp := OCTO_KEY_2 if tmp key begin next-level end
        #tmp := OCTO_KEY_1 if tmp key begin prev-level end
    end
    i := moveset
    save movedata
}

:macro check-lines {
    i := moveset
    load movedata
    if direction == 1 begin horizontal-step end
    if direction == 2 begin vertical-step end
    i := moveset
    save movedata
}

# Messes up:
# Fill in an area of the screen.
:alias fillx v4
:alias filly v5
:alias dotwidth v6
: runfill
    i := fillset
    load filldata

    # Split with ball to left/top sets 1
    # Split with ball to right/bottom sets 2
    # If neither bit is set we don't fill - although probably something went wrong in this case.
    # If both bits are set we don't fill - there's a ball on both sides still.
    if fillshouldfill == 0 then return
    if fillshouldfill == 3 then return

    fillx := fillstartx
    filly := fillstarty

# Fill from left to right,
# in Top-to-bottoms stripes
    loop
        # Calculate the stripewidth. If there's a lot left to fill, it's 8.
        # Otherwise, it is the amount left to fill.
        dotwidth := fillendx 
        dotwidth -= fillx
        if dotwidth > 8 then dotwidth := 8

        # Get the graphic location corresponding to this vertical stripe.
        i := beforedots 
        i += dotwidth

        loop
            sprite fillx filly 1

            while filly != fillendy
            filly += 1
        again

        # We hit the bottom, move over
        fillx += dotwidth
        filly := fillstarty

        while fillx < fillendx
    again
;

### Boundary crossing notes:
# The math is simple, and we can use the same pattern for both directions, 
# but there's a lot to keep track of.
# Consider the x dimension:
# We are either moving left (decreasing) or moving right (increasing).
#
# First, we subtract the boundary from the coordinate, so that we're working
# relative to a boundary of 0.
#
# Now, we add the speed to the coordinate.
# 
# The movement results in a crossing based on the value of the vf carry flag. BUT, 
# the value expect depends on the direction of movement. If we were moving left,
# Then when we cross, we expect to *not* get the carry flag.
# For example:
#   x = 5, dx = -2, left = 4. 
#   We adjusted for the boundary, so x = 1.
#   x + dx ->   
#   1 + -2 -> 
#   0x01 + 0xFE -> 0xFF. Note that there was no carry!
#   In other words, adding -2 gives the same vf as subtracting 2. 
#
#   For a non cross:
#   x = 5 dx = -1 left = 3
#   x = 2 after bounds adjust.
#   x + dx -> 2 + -2 -> 0x02 + 0xFE -> 0x00 -- a carry!
#
#   We only check left bound when moving left and right bound when moving right, so 
#   there's no need for the math to work out on the opposite boundaries (and no need 
#  do those pointless checks).



### Single macro to handle bounds check.
# coord: the current value of the coordinate checked
# velo: the speed along the dimension
# bound: the bound we are checking against
# expect: the carry flag the indicates a hit (see notes above)
:macro checkbound coord velo bound hitwhencarryis {
    # do math to calculate a boundary crossing.
    coord -= bound
    coord += velo
    if vf == hitwhencarryis begin 
        # clip to bound
        coord := bound
        # negate velocity
        tmp2 := 0
        velo =- tmp2
        # TODO - maybe random it up a little?
    else
        coord += bound
    end	
}

### Call the appropriate checkbound for a coordinate
:macro ud2 coordinate velocity boundStart boundEnd {
    # Find sign of velocity
    # Shifts left one, MSB goes into vF (sign)
    # We're ready for both shift behaviors!
    sign := velocity
    sign <<= velocity

    if sign == 1 begin
        # We are moving to the left, or up (decreasing coord)
        # So check for corssing the start/minimum boundary
        checkbound coordinate velocity boundStart 0
        else 
        # We are moving to the right, or down (increasing coord)
        # So check for corssing the end/maximum boundary
        checkbound coordinate velocity boundEnd 1
    end
}

: hmoveball
    if va != 2 then jump hjustdraw

    if by < v8 then jump hjustdraw
    if by > v9 then jump hjustdraw

    if bx < vb begin
        ud2 bx dx left right
        if bx >= vb then jump lose
        return
    end

    if bx > vb begin
        ud2 bx dx left right
        if bx <= vb then jump lose
        return
    end
        
    : hjustdraw 
    ud2 bx dx left right
;

: vmoveball
    if va != 1 then jump vjustdraw

    if bx < v8 then jump vjustdraw
    if bx > v9 then jump vjustdraw

    if by < vb begin
        ud2 by dy top bottom
        if by >= vb then jump lose
        return
    end

    if by > vb begin
        ud2 by dy top bottom
        if by <= vb then jump lose
        return
    end
        
    : vjustdraw 
    ud2 by dy top bottom
;

: moveball
    i := dot
    sprite bx by 1
    hmoveball
    vmoveball
    i := dot
    sprite bx by 1
;

: lose
    v0 := random 0xFF
    v1 := random 0xFF
    i := b1
    i += v0 
    sprite v0 v1 8
    jump lose
# repack as 
# x dx l r y dy t b
# So we can do smaller loads
#  x y dx dy t l r b
# dx/dy == 0 signals ball not yet active
# and we assume that all subsequence aren't either
: b1
    3 3 -1 2 0 0 63 31
: b2
    35 11 -2 1 0 0 63 31
: b3
    17 21 0 0 0 0 63 31
: b4
    45 20 0 0 0 0 63 31
: b5
    0 0 0 0 0 0 63 31
: b6
    0 0 0 0 0 0 63 31
: b7
    0 0 0 0 0 0 63 31
: b8
    0 0 0 0 0 0 63 31
: b-end

: moveset
# px py start end direction(1=h, 2=v) 
  10 10  

  0     0   
: movetargets
  0
  0    0
  0

: fillset
# x bounds for fill
: filldatastartx
  0 
: filldataendx
  0
# y bounds for fill
: filldatastarty
  0
: filldataendy
  0
: filldatashouldfill
  0

: beforedots 0xFF
# Various width "dots" for the remainder part of the fill routine.
: dot 0x80 
: dot2 0xC0 
: dot3 0xE0
: dot4 0xF0
: dot5 0xF8
: dot6 0xFC
: dot7 0xFE
: dot8 0xFF
: data

# .X.
# X.X
# .X.
#
# As .X
#    X.
# drawn twice.

: crosshair
            0x40
            0x80

: main
    i := moveset
    load v6
    draw-crosshair
    init-level

    loop
        check-keys

        tmp := delay
        if tmp == 0 begin
            check-lines
            move-all
            tmp := 3
            delay := tmp
        end

    again


