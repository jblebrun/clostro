# Ball and region set, moved by moveball.
:alias bx v0
:alias by v1
:alias dx v2
:alias dy v3
:alias top v4
:alias left v5
:alias right v6
:alias bottom v7

# Move set
:alias px v0
:alias py v1
:alias start v2
:alias finish v3
:alias mark v4
:alias direction v5

:alias sign vf
:alias tmp vd
:alias tmp2 ve
:alias tmp3 vc
:alias tmp4 vb
:alias tmp5 va

:macro init bn {
    i := bn
    load v7
    if dx != 0 begin
        i := dot
        sprite bx by 1
    end
}

:macro m bn {
    i := bn
    load v7
    if dx != 0 begin
        moveball
        i := bn
        save v7
    end
}


:macro horizontal {
    i := crosshair
    sprite px py 3
    start := px
    finish := px
    mark := py
    direction := 1
}

# Attempt to split the region for ball 1
:macro h-split-regions {
    tmp2 := mark
    i := b1
    load v7
    if bx < tmp2 begin
        if mark < right then right := mark
    end
    if bx >= tmp2 begin 
        if mark > left then left := mark
    end
    save v7
}

:macro horizontal-step {
    i := dot
    tmp := 0
    if start != 1 begin start -= 1 sprite start mark 1 tmp += 1 end
    if start != 1 begin start -= 1 sprite start mark 1 tmp += 1 end
    if start != 1 begin start -= 1 sprite start mark 1 tmp += 1 end
    if start != 1 begin start -= 1 sprite start mark 1 tmp += 1 end
    if finish != 63 begin finish += 1 sprite finish mark 1 tmp += 1 end
    if finish != 63 begin finish += 1 sprite finish mark 1 tmp += 1 end
    if finish != 63 begin finish += 1 sprite finish mark 1 tmp += 1 end
    if finish != 63 begin finish += 1 sprite finish mark 1 tmp += 1 end
    if tmp == 0 begin
        i := crosshair
        sprite px py 3
        direction := 0
    end
}

:macro vertical {
    i := crosshair
    sprite px py 3
    start := py
    finish := py
    mark := px
    direction := 2
}

:macro vertical-step {
    tmp := 0
    i := dot
    if start != 1 begin start -= 1 sprite mark start 1 tmp += 1 end
    if start != 1 begin start -= 1 sprite mark start 1 tmp += 1 end
    if finish != 31 begin finish += 1 sprite mark finish 1 tmp += 1 end
    if finish != 31 begin finish += 1 sprite mark finish 1 tmp += 1 end
    if tmp == 0 begin
        i := crosshair
        sprite px py 3
        direction := 0
        #ah-split-regions
    end
}

:macro move-crosshair coord amt bound boundfix {
    i := crosshair
    sprite px py 3
    coord += amt
    if coord == bound then coord := boundfix
    sprite px py 3
}


# Go through the balls until one isn't one, turn it on
:macro next-level {
    tmp := 0
    init-level
    loop
        i := b1
        i += tmp
        load v8
        if dx == 0 begin
            dx := 1
            dy := 1
            tmp := 64
            save v8
            init-level
        else
            tmp += 8
        end
        while tmp != 64
    again
    tmp := OCTO_KEY_2 
    loop
        while tmp key 
    again
}

:macro check-keys {
    i := moveset
    load v5
    if direction == 0 begin
        tmp := OCTO_KEY_W if tmp key begin move-crosshair py -1 255 0 end
        tmp := OCTO_KEY_S if tmp key begin move-crosshair py 1 30 29 end
        tmp := OCTO_KEY_A if tmp key begin move-crosshair px -1 255 0 end
        tmp := OCTO_KEY_D if tmp key begin move-crosshair px 1 62 61 end
        tmp := OCTO_KEY_Q if tmp key begin vertical end
        tmp := OCTO_KEY_E if tmp key begin horizontal end
        tmp := OCTO_KEY_2 if tmp key begin next-level end
        #tmp := OCTO_KEY_1 if tmp key begin prev-level end
    end
    i := moveset
    save v5
}

:macro check-lines {
    i := moveset
    load v5
    if direction == 1 begin horizontal-step end
    if direction == 2 begin vertical-step end
    i := moveset
    save v5
}

#

### Boundary crossing notes:
# The math is simple, and we can use the same pattern for both directions, 
# but there's a lot to keep track of.
# Consider the x dimension:
# We are either moving left (decreasing) or moving right (increasing).
#
# First, we subtract the boundary from the coordinate, so that we're working
# relative to a boundary of 0.
#
# Now, we add the speed to the coordinate.
# 
# The movement results in a crossing based on the value of the vf carry flag. BUT, 
# the value expect depends on the direction of movement. If we were moving left,
# Then when we cross, we expect to *not* get the carry flag.
# For example:
#   x = 5, dx = -2, left = 4. 
#   We adjusted for the boundary, so x = 1.
#   x + dx ->   
#   1 + -2 -> 
#   0x01 + 0xFE -> 0xFF. Note that there was no carry!
#   In other words, adding -2 gives the same vf as subtracting 2. 
#
#   For a non cross:
#   x = 5 dx = -1 left = 3
#   x = 2 after bounds adjust.
#   x + dx -> 2 + -2 -> 0x02 + 0xFE -> 0x00 -- a carry!
#
#   We only check left bound when moving left and right bound when moving right, so 
#   there's no need for the math to work out on the opposite boundaries (and no need 
#  do those pointless checks).



### Single macro to handle bounds check.
# coord: the current value of the coordinate checked
# velo: the speed along the dimension
# bound: the bound we are checking against
# expect: the carry flag the indicates a hit (see notes above)
:macro checkbound coord velo bound hitwhencarryis {
    # do math to calculate a boundary crossing.
    coord -= bound
    coord += velo
    if vf == hitwhencarryis begin 
        # clip to bound
        coord := bound
        # negate velocity
        tmp := 0
        velo =- tmp
        # TODO - maybe random it up a little?
    else
        coord += bound
    end	
}

### Call the appropriate checkbound for a coordinate
:macro ud2 coordinate velocity boundStart boundEnd {
    # Find sign of velocity
    # Shifts left one, MSB goes into vF (sign)
    # We're ready for both shift behaviors!
    sign := velocity
    sign <<= velocity

    if sign == 1 begin
        # We are moving to the left, or up (decreasing coord)
        # So check for corssing the start/minimum boundary
        checkbound coordinate velocity boundStart 0
        else 
        # We are moving to the right, or down (increasing coord)
        # So check for corssing the end/maximum boundary
        checkbound coordinate velocity boundEnd 1
    end
}

: moveball
    i := dot
    sprite bx by 1
    ud2 bx dx left right
    ud2 by dy top bottom
    i := dot
    sprite bx by 1
;

# repack as 
# x dx l r y dy t b
# So we can do smaller loads
#  x y dx dy t l r b
# dx/dy == 0 signals ball not yet active
# and we assume that all subsequence aren't either
: b1
    3 3 -1 2 0 0 63 31
: b2
    35 11 0 0 0 0 63 31
: b3
    17 21 0 0 0 0 63 31
: b4
    45 20 0 0 0 0 63 31
: b5
    0 0 0 0 0 0 63 31
: b6
    0 0 0 0 0 0 63 31
: b7
    0 0 0 0 0 0 63 31
: b8
    0 0 0 0 0 0 63 31
: b-end

: moveset
# px py start end mark direction(1=h, 2=v) 
  10 10  0     0   0    0

: dot
    0x80

: crosshair
            0x40
            0xA0
            0x40
            0x00

:macro init-level {
    init b1
    init b2
    init b3
    init b4
    init b5
    init b6
    init b7
    init b8
}

:macro move-all {
    m b1
    m b2
    m b3 
    m b4
    m b5
    m b6 
    m b7 
    m b8
}

: main
    i := moveset
    load v6
    i := crosshair
    sprite px py 3
    init-level

    loop
        check-keys

        tmp := delay
        if tmp == 0 begin
            check-lines
            move-all
            tmp := 3
            delay := tmp
        end

    again


