:const BALLDATA_SIZE 8
:const BALLDATA_END 64
:const SHOULD_FILL_MASK_START 1
:const SHOULD_FILL_MASK_FINISH 2

:const DRAW_HORIZONTAL 1
:const DRAW_VERTICAL 2
# FLAG_FINISHED indicates that an action finished.
# We won't handle an action press again until 
# the key is released after a line finishes.
:const FLAG_FINISHED 4
:const FINISHED_HORIZONTAL 5
:const FINISHED_VERTICAL 6

### Change to 2 for hires
:const HIRES  1
:calc WIDTH { 0x40 * HIRES }
:calc XMAX { WIDTH - 1 }
:calc HEIGHT { 0x20 * HIRES }
:calc YMAX { HEIGHT - 1 }
:const SPEED HIRES
:calc WINSCORE { 7 * HIRES * HIRES } 


# General register strategy
# v0 - v7 often contain sets loaded from memory
# vf is vf
# ve is usually a loop offset, or some other extremely temporary thing.
# v8-vd are medium temporary, they might live between calls, holding some
#       bits of data from a different v0-v7 set, for example.


### Common register sets ###
# A set of data about one of the balls.
# Swapped in during the move calculations.
:alias bx v0
:alias by v1
:alias dx v2
:alias dy v3
:alias top v4
:alias left v5
:alias right v6
:alias bottom v7
:alias balldata v7
    

# Player data set
# Swapped in during movement key handling and line drawing.
:alias px v0
:alias py v1
:alias start v2
:alias finish v3
:alias direction v4
:alias start-target v5
:alias finish-target v6
:alias mark v7
:alias movedata v7

# Fill data
:alias fillstartx v0
:alias fillendx v1
:alias fillstarty v2
:alias fillendy v3
:alias fillshouldfill v4
:alias filldata v4

# Permanent
:alias offset ve # for looping over ballset
:alias sign vf

# moveset should be loaded
:macro draw-crosshair {
    i := crosshair
    sprite px py 2
    px -= 1
    py -= 1
    sprite px py 2
    px += 1
    py += 1
}

# moveset should be loaded
:macro move-crosshair coord amt bound {
    draw-crosshair
    coord += amt
    if coord == bound then coord -= amt 
    draw-crosshair
}

####################
### LINE DRAWING ###
####################

# Run on each loop to draw part of a player line
:macro check-lines {
    i := moveset
    load movedata
    if direction == DRAW_HORIZONTAL begin horizontal-step end
    if direction == DRAW_VERTICAL begin vertical-step end
    i := moveset
    save movedata
}


########################
### LINE ACTION INIT ###
########################

# Used by maybe-start-line-drawing to decide if the player is 
# In an unfilled region, and so could draw a line.
# For each active region, we check that px, py are full 
# in the bounds of that region.
# If they are, we save the line-drawing bounds, and the drawing
# direction into the line-data.
# This includes setting the direction of moveset to check-direction,
# which will signal for the move to proceed.
:alias check-player-x vd
:alias check-player-y vc
:alias check-direction vb
: check-in-region
    offset := 0
    check-player-x := px
    check-player-y := py
    v0 := v0
    loop
        i := b1
        i += offset 
        load balldata

        if dx == 0 then return

        if check-player-x >= right then jump next-check
        if check-player-x <= left then jump next-check
        if check-player-y >= bottom then jump next-check
        if check-player-y <= top then jump next-check

        if check-direction == DRAW_HORIZONTAL begin
            v3 := left # left is v5, set before overwriting
            v0 := check-player-x 
            v1 := check-player-x
            v2 := check-direction
            v4 := right
            v5 := check-player-y
        else
            v3 := top # top is v4, set before overwriting
            v0 := check-player-y
            v1 := check-player-y 
            v2 := check-direction 
            v4 := bottom
            v5 := check-player-x
        end
        i := line-data 
        save v5
        return

        : next-check
        offset += BALLDATA_SIZE
        while offset != BALLDATA_END
    again
;

# in check-direction = 1 - horizontal
#           2 - vertical
: maybe-start-line-drawing
    check-in-region
    i := moveset
    load movedata
    if direction == check-direction begin
        # undraw crosshair
        draw-crosshair

        # first dot for the player line
        i := dot
        sprite px py 1
    end
;


# Called from split-regions, assumes that the ball data
# set at b1 + offset was previously loaded, and will restore it.
:macro handle-region-split bound coord fillloc fillloc2 mask diff {
    # Save the provided bound to the provided location.
    # This is going to be one of the fill boundaries.
    v0 := bound
    i := fillloc
    save v0

    # Since we're drawing a line already, we don't need to account for it while
    # filling later.
    v0 := coord
    v0 -= diff
    i := fillloc2
    save v0

    # Save a mask that indicates the direction that we shrunk.
    i := filldatashouldfill
    load v0
    v1 := mask
    v0 |= v1
    i := filldatashouldfill
    save v0

    # Restore ball data.
    i := b1
    i += offset
    load v1
    bound := coord
    bound += diff
}


# Checks to see if we should actually split the region in the given direction.
:macro maybe-check-region-split 
    DIRECTION 
    splitting-coord 
    ball-coord 
    start-bound finish-bound
    filldata-start filldata-end
{
    if splitting-direction == DIRECTION begin
        if ball-coord <= splitting-coord begin
            if splitting-coord < finish-bound begin
                handle-region-split finish-bound splitting-coord filldata-end filldata-start SHOULD_FILL_MASK_FINISH -1
            end
        end
        if ball-coord >= splitting-coord begin
            if splitting-coord > start-bound begin
                handle-region-split start-bound splitting-coord filldata-start filldata-end SHOULD_FILL_MASK_START 1
            end
        end
    end
}

:alias splitting-x va
:alias splitting-y vd
:alias splitting-direction vc

# Called when a line-drawing sequence has finished (reached bounds on both sides
# This goes through each active ball region and determines if we have reduced the 
# size of this region. Resizes the region for each ball as appropriate. 

# As it's going, it also tracks whether a region shrink leaves any area with no 
# balls in it. This information is recorded in filldata.
: split-regions
    splitting-x := px
    splitting-y := py
    splitting-direction := direction
    offset := 0
    
    i := moveset
    save movedata

    # Account for the line in the score
    i := score
    load v1
    v2 := finish-target
    v2 -= start-target
    v0 += v2
    v1 += vf
    i := score
    save v1
    v0 := v0

    # Set up the potential fill region 
    # (if there's a ball on only one side of the split)
    if direction == FINISHED_HORIZONTAL begin
        v0 := start-target    # filldatastartx
        v1 := finish-target   # filldataendx
        v2 := splitting-y     # filldatastarty
        v3 := splitting-y     # filldataendy
    else 
        v0 := splitting-x     # filldatastartx
        v1 := splitting-x     # filldataendx
        v2 := start-target    # filldatastarty
        v3 := finish-target   # filldataendy
    end
    v4 := 0 # should fill
    i := fillset
    save filldata


    loop
        i := b1
        i += offset
        load balldata
        
        if dx == 0 then jump next-regions
        if splitting-x <= left then jump next-regions
        if splitting-x >= right then jump next-regions
        if splitting-y <= top then jump next-regions
        if splitting-y >= bottom then jump next-regions

        maybe-check-region-split FINISHED_HORIZONTAL splitting-y by top bottom filldatastarty filldataendy
        maybe-check-region-split FINISHED_VERTICAL splitting-x bx left right filldatastartx filldataendx

        i := b1
        i += offset
        save balldata
        : next-regions
        offset += BALLDATA_SIZE
        while offset != BALLDATA_END
    again

    runfill
    
    i := moveset
    load movedata
;


:macro step coord target diff x y {
    if coord != target begin coord += diff sprite x y 1 steps-taken += 1 end
}

:macro steps x1 y1 x2 y2 {
    i := dot
    steps-taken := 0
    step start start-target -1 x1 y1 
    step start start-target -1 x1 y1 
    step start start-target -1 x1 y1 
    step finish finish-target 1 x2 y2
    step finish finish-target 1 x2 y2
    step finish finish-target 1 x2 y2
    if steps-taken == 0 begin
        draw-crosshair
        vf := FLAG_FINISHED
        direction |= vf
        split-regions 
    end
}

# Active set: moveset
:alias steps-taken ve
:macro horizontal-step {
    steps start py finish py
}

# Active set: moveset
:macro vertical-step {
    steps px start px finish
}

# Go through the balls until one isn't one, turn it on
:macro next-level {
    i := level
    load v0
    vd := v0
    v0 := 0
    v1 := 0
    i := score
    save v1
    offset := 0
    loop
        i := b1
        i += offset
        load balldata
        bx := random XMAX
        by := random YMAX 
        dx := SPEED
        dy := SPEED
        vf := random 1
        if vf == 1 begin
            vf := random 1
            if vf == 1 begin dx += 1 else dy += 1 end 
        end
        top := 0
        left := 0
        right := XMAX
        bottom := YMAX 
        i := b1
        i += offset
        save balldata
        i := dot
        sprite px py 1
        offset += BALLDATA_SIZE
        while offset != BALLDATA_END
        while vd != 0
        vd -= 1
    again
    i := moveset
    load movedata
}

# Clobbers v0-v5
:alias checking-key vd
:macro check-keys {
    i := moveset
    load movedata
    if direction == 0 begin
        checking-key := OCTO_KEY_W if checking-key key begin move-crosshair py -1 -1 end
        checking-key := OCTO_KEY_S if checking-key key begin move-crosshair py 1 HEIGHT end
        checking-key := OCTO_KEY_A if checking-key key begin move-crosshair px -1 -1 end
        checking-key := OCTO_KEY_D if checking-key key begin move-crosshair px 1 WIDTH end
        checking-key := OCTO_KEY_Q if checking-key key begin check-direction := DRAW_VERTICAL maybe-start-line-drawing end
        checking-key := OCTO_KEY_E if checking-key key begin check-direction := DRAW_HORIZONTAL maybe-start-line-drawing end
        checking-key := OCTO_KEY_2 if checking-key key begin level-clear end
    end
    if direction == FINISHED_VERTICAL begin 
        checking-key := OCTO_KEY_Q if checking-key -key then direction := 0
    end
    if direction == FINISHED_HORIZONTAL begin 
        checking-key := OCTO_KEY_E if checking-key -key then direction := 0
    end
    i := moveset
    save movedata
}

# Messes up:
# Fill in an area of the screen.
:alias fillx v4
:alias filly v5
:alias dotwidth v6
:alias score-add-lo v7
:alias score-add-hi v8
: runfill

    i := score
    load v1
    score-add-lo := v0
    score-add-hi := v1
    v0 := v0

    i := fillset
    load filldata

    # Split with ball to left/top sets 1
    # Split with ball to right/bottom sets 2
    # If neither bit is set we don't fill - although probably something went wrong in this case.
    # If both bits are set we don't fill - there's a ball on both sides still.
    if fillshouldfill == 0 then return
    if fillshouldfill == 3 then return

    fillendx += 1
    fillx := fillstartx
    filly := fillstarty
# Fill from left to right,
# in Top-to-bottoms stripes
    loop
        # Calculate the stripewidth. If there's a lot left to fill, it's 8.
        # Otherwise, it is the amount left to fill.
        dotwidth := fillendx 
        dotwidth -= fillx
        if dotwidth > 8 then dotwidth := 8

        # Get the graphic location corresponding to this vertical stripe.
        i := beforedots 
        i += dotwidth

        loop
            sprite fillx filly 1

            score-add-lo += dotwidth
            score-add-hi += vf

            while filly != fillendy
            filly += 1
        again

        # We hit the bottom, move over
        fillx += dotwidth
        filly := fillstarty

        while fillx < fillendx
    again

    if score-add-hi >= WINSCORE begin
        level-clear 
    else 
        v0 := score-add-lo
        v1 := score-add-hi
        i := score
        save v1
        v0 := v0
    end
;


############################
### BALL MOVING ROUTINES ###
############################


# v8-vb hold information needed to 
# determine if a ball is crossing
# a line that's being drawn.
# The ball data set is v0-v7, so
# we start at v8.
:alias movecalc-start v8
:alias movecalc-finish v9
:alias movecalc-direction va
:alias movecalc-mark vb
# Set for-each-ball-action to a valid call
# And then call this
: move-all 
    movecalc-start := start
    movecalc-finish := finish
    movecalc-direction := direction
    if direction == DRAW_HORIZONTAL then movecalc-mark := py
    if direction == DRAW_VERTICAL then movecalc-mark := px

    offset := 0
    loop
        i := b1
        i += offset
        load balldata
        if dx != 0 begin
            moveball
            if vf == 1 then return
            i := b1
            i += offset
            save balldata
            offset += BALLDATA_SIZE
        else 
            offset := BALLDATA_END
        end
        while offset != BALLDATA_END
    again
    vf := 0
;

### Boundary crossing notes:
# The math is simple, and we can use the same pattern for both directions, 
# but there's a lot to keep track of.
# Consider the x dimension:
# We are either moving left (decreasing) or moving right (increasing).
#
# First, we subtract the boundary from the coordinate, so that we're working
# relative to a boundary of 0.
#
# Now, we add the speed to the coordinate.
# 
# The movement results in a crossing based on the value of the vf carry flag. BUT, 
# the value expect depends on the direction of movement. If we were moving left,
# Then when we cross, we expect to *not* get the carry flag.
# For example:
#   x = 5, dx = -2, left = 4. 
#   We adjusted for the boundary, so x = 1.
#   x + dx ->   
#   1 + -2 -> 
#   0x01 + 0xFE -> 0xFF. Note that there was no carry!
#   In other words, adding -2 gives the same vf as subtracting 2. 
#
#   For a non cross:
#   x = 5 dx = -1 left = 3
#   x = 2 after bounds adjust.
#   x + dx -> 2 + -2 -> 0x02 + 0xFE -> 0x00 -- a carry!
#
#   We only check left bound when moving left and right bound when moving right, so 
#   there's no need for the math to work out on the opposite boundaries (and no need 
#  do those pointless checks).



### Single macro to handle bounds check.
# coord: the current value of the coordinate checked
# velo: the speed along the dimension
# bound: the bound we are checking against
# expect: the carry flag the indicates a hit (see notes above)
:macro checkbound coord velo bound hitwhencarryis {
    # do math to calculate a boundary crossing.
    coord -= bound
    coord += velo
    if vf == hitwhencarryis begin 
        # clip to bound
        coord := bound
        # negate velocity
        vf := 0
        velo =- vf
        vf := 2
        buzzer := vf
        # TODO - maybe random it up a little?
    else
        coord += bound
    end	
}

### Call the appropriate checkbound for a coordinate
:macro ud2 coordinate velocity boundStart boundEnd {
    # Find sign of velocity
    # Shifts left one, MSB goes into vF (sign)
    # We're ready for both shift behaviors!
    sign := velocity
    sign <<= velocity

    if sign == 1 begin
        # We are moving to the left, or up (decreasing coord)
        # So check for corssing the start/minimum boundary
        checkbound coordinate velocity boundStart 0
        else 
        # We are moving to the right, or down (increasing coord)
        # So check for corssing the end/maximum boundary
        checkbound coordinate velocity boundEnd 1
    end
}

# vf is 1 on return if collided with line
: hmoveball
    if movecalc-direction != DRAW_VERTICAL then jump hjustdraw

    if by < movecalc-start then jump hjustdraw
    if by > movecalc-finish then jump hjustdraw

    if bx < movecalc-mark begin
        ud2 bx dx left right
        if bx >= movecalc-mark then vf := 1
        return
    end

    if bx > movecalc-mark begin
        ud2 bx dx left right
        if bx <= movecalc-mark then vf := 1
        return
    end
        
    : hjustdraw 
    ud2 bx dx left right
    vf := 0
;

# vf is 1 on return if collided with line
: vmoveball
    if movecalc-direction != DRAW_HORIZONTAL then jump vjustdraw

    if bx < movecalc-start then jump vjustdraw
    if bx > movecalc-finish then jump vjustdraw

    if by < movecalc-mark begin
        ud2 by dy top bottom
        if by >= movecalc-mark then vf := 1
        return
    end

    if by > movecalc-mark begin
        ud2 by dy top bottom
        if by <= movecalc-mark then vf := 1
        return
    end
        
    : vjustdraw 
    ud2 by dy top bottom
    vf := 0
;

: moveball
    i := dot
    sprite bx by 1
    hmoveball
    if vf == 1 then return
    vmoveball
    if vf == 1 then return
    i := dot
    sprite bx by 1
    vf := 0
;

: drawsplode
    v0 := random 0x18
    v1 := random 0x3c
    v2 := random 0x7e
    v3 := random 0xff
    v4 := random 0xff
    v5 := random 0x7e
    v6 := random 0x3c
    v7 := random 0x18
    i := splosion
    save v7
    i := splosion
    sprite va vb 8
;


: splode
    loop
        vf := delay
        if vf == 0 begin
            vf := 2
            delay := vf
            va -= v9
            vb -= v9
            drawsplode
            va += v9
            va += v9
            drawsplode
            vb += v9
            vb += v9
            drawsplode
            va -= v9
            va -= v9
            drawsplode
            va += v9
            vb -= v9

            vf := 1
            buzzer := vf
            v8 -= 1
            while v8 != 0
        end
    again
;

: lose
    va := bx
    vb := by
    va -= 3
    vb -= 3

    v8 := 15
    v9 := 0
    splode

    v8 := 25
    v9 := 2
    splode

    vc := 60
    loop
        ve := random 0x7
        vf := random 0x1
        if vf == 1 begin va += ve else va -= ve end
        ve := random 0x7
        vf := random 0x1
        if vf == 1 begin vb += ve else vb -= ve end
        v8 := 1
        v9 := 3
        splode
        vc -= 1
        while vc != 0
    again

    vc := 120
    loop
        va := random XMAX 
        vb := random YMAX 
        v8 := 1
        v9 := 3
        splode
        vc -= 1
        while vc != 0
    again
    

    v0 := key
    loop 
        while v0 key
    again
;

: splosion
    0 0 0 0 0 0 0 0 


: draw-face
    v2 := 8
    v0 := 24 v1 := 8
    sprite v0 v1 8
    
    v0 := 32 v1 := 8
    i += v2
    sprite v0 v1 8
    
    v0 := 24 v1 := 16
    i += v2
    sprite v0 v1 8
    
    v0 := 32 v1 := 16
    i += v2
    sprite v0 v1 8
;

:macro wait n {
    v2 := n
    delay := v2
    loop
        v2 := delay
        while v2 != 0
    again
}
: draw-around
    i := hex v8
    v0 := 15
    v1 := 1
    loop
        sprite v0 v1 5
        v0 += 6
        while v0 != 51
        wait 5
    again
    v0 -= 6
    v1 += 6
    loop
        sprite v0 v1 5
        v1 += 6
        while v1 != 31
        wait 5
    again
    v1 -= 6
    v0 -= 6
    loop
        sprite v0 v1 5
        v0 -= 6
        while v0 != 9
        wait 5
    again
    v0 += 6
    v1 -= 6
    loop
        sprite v0 v1 5
        v1 -= 6
        while v1 != 1
        wait 5
    again

;

: level-clear
    clear
    i := level
    load v0
    v0 += 1
    i := level
    save v0

    v8 := v0

    i := transition-grimace-tl
    draw-face

    draw-around
    
    i := transition-grimace-tl
    draw-face
    i := transition-face-tl
    draw-face

    v0 := key
    loop
        while v0 key
    again
    clear
    playstart 
;


:macro letter x y name {
    v0 := x v1 := y
    i := name
    sprite v0 v1 11
}

:macro init-balls src dst {
    offset := 0
    loop 
        i := src
        i += offset
        load v7
        i := dot
        sprite bx by 1
        i := dst
        i += offset
        save v7
        offset += 8
        while offset != 24
    again
}


: title-screen
    clear
    init-balls b1-title b1

    letter 14 4 title-c
    letter 23 4 title-l
    letter 32 4 title-o
    letter 41 4 title-s

    letter 18 17 title-t
    letter 27 17 title-r
    letter 36 17 title-o

    loop
        vf := delay
        if vf == 0 begin
            vf := 5
            delay := vf
            move-all
        end
        v0 := 0
        loop 
            if v0 key then jump done
            v0 += 1
            while v0 != 0x10
        again
            
    again
    : done
    loop 
        while v0 key
    again

    init-balls b-empty b1
    clear
;

: title-c 0xFE 0x80 0x80 0x80 0x80 0x80 0x80 0x80 0x80 0x80 0xFE

: title-l 0x80 0x80 0x80 0x80 0x80 0x80 0x80 0x80 0x80 0x80 0xFE

: title-o 0xFE 0x82 0x82 0x82 0x82 0x82 0x82 0x82 0x82 0x82 0xFE

: title-s 0xFE 0x80 0x80 0x80 0x80 0xFE 0x02 0x02 0x02 0x02 0xFE

: title-t 0xFE 0x10 0x10 0x10 0x10 0x10 0x10 0x10 0x10 0x10 0x10

: title-r 0xFE 0x82 0x82 0x82 0x82 0xFE 0x88 0x88 0x88 0x88 0x88


# repack as 
# x dx l r y dy t b
# So we can do smaller loads
#  x y dx dy t l r b
# dx/dy == 0 signals ball not yet active
# and we assume that all subsequence aren't either
: b1 0  0   0  0  0  0  63 31
: b2 0  0   0  0  0  0  63 31
: b3 0  0   0  0  0  0  63 31
: b4 0  0   0  0  0  0  63 31
: b5 0  0   0  0  0  0  63 31
: b6 0  0   0  0  0  0  63 31
: b7 0  0   0  0  0  0  63 31
: b8 0  0   0  0  0  0  63 31

: b-empty 0 0 0 0 0 0 0 0 
: b-empty2 0 0 0 0 0 0 0 0 
: b-empty3 0 0 0 0 0 0 0 0 
: b1-title 33 6   1  3  5  33 37 13
: b2-title 37 18  2  1  18 37 41 26
: b3-title 15 5   1  1  5  15 22 13

: moveset
: player-coordinates 0 0
: line-data
: line-progress 0 0
: line-direction 0
: line-bounds 0 0
: line-mark 0

: score 0 0

: level 0

: fillset
: filldatastartx 0 
: filldataendx 0
# y bounds for fill
: filldatastarty 0
: filldataendy 0
: filldatashouldfill 0

: beforedots 0xFF
# Various width "dots" for the remainder part of the fill routine.
: dot 0x80 
: dot2 0xC0 
: dot3 0xE0
: dot4 0xF0
: dot5 0xF8
: dot6 0xFC
: dot7 0xFE
: dot8 0xFF
: data


: transition-face-tl
0x1F 0x20 0x40 0x88 0x94 0x80 0x80 0x81
: transition-face-tr
0xF8 0x04 0x02 0x21 0x51 0x01 0x01 0x01
: transition-face-bl
0x80 0x80 0x9F 0x88 0x84 0x43 0x20 0x1F 
: transition-face-br
0x01 0x01 0xF9 0x11  0x21 0xC2 0x04 0xF8

: transition-grimace-tl
0x1F 0x20 0x40 0x88 0x84 0x88 0x80 0x80 
: transition-grimace-tr
0xF8 0x04 0x02 0x21 0x11 0x21 0x01 0x01
: transition-grimce-bl
0x81 0x80 0x80 0x8F 0x8A 0x4F 0x20 0x1F
: transition-grimce-br
0x81 0x01 0x01 0xF1 0x51 0xF2 0x04 0xF8


# .X.
# X.X
# .X.
#
# As .X
#    X.
# drawn twice.

: crosshair
            0x40
            0x80
: ball
            0x80


: playstart
    px := 0x20
    py := 0x10
    direction := 0
    draw-crosshair
    i := moveset
    save movedata
    next-level
;

:alias delay-check ve
: main
#   v0 := WIDTH
#if v0 == 0x80 then hires
    loop 
        i := level
        v0 := 0
        save v0
        title-screen

        playstart

        loop
            check-keys

            delay-check := delay
            if delay-check == 0 begin
                delay-check := 5
                delay := delay-check
                check-lines
                move-all
                if vf == 1 then jump lost
            end

        again
        : lost
        lose
    again


